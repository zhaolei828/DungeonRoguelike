# åœ°å›¾è¿é€šæ€§ç³»ç»Ÿè‡ªæ£€æŠ¥å‘Š

**æ—¥æœŸ**: 2025-10-22  
**å¯¹æ¯”åŸºå‡†**: Shattered Pixel Dungeon (SPD) æºä»£ç   
**å‚è€ƒæ–‡æ¡£**: DungeonGeneration_Technical_Report_CN.md  

---

## æ‰§è¡Œæ‘˜è¦

### âœ… å·²å®ç°çš„åŠŸèƒ½
1. **PathFinderå·¥å…·ç±»** - BFSè·ç¦»åœ°å›¾æ„å»º
2. **Levelå±‚è¿é€šæ€§éªŒè¯** - åœ°å›¾ç”ŸæˆåéªŒè¯
3. **RespawnManagerå¯è¾¾æ€§æ£€æŸ¥** - é‡ç”Ÿä½ç½®éªŒè¯
4. **ç¼–è¾‘å™¨è¯Šæ–­å·¥å…·** - å¯è§†åŒ–ä¸å¯è¾¾åŒºåŸŸ

### âš ï¸ å…³é”®ç¼ºå¤±
**PatchRoomå±‚çš„è¿é€šæ€§æ£€æŸ¥** - è¿™æ˜¯SPDé˜²æ­¢æˆ¿é—´å†…æ­»èƒ¡åŒçš„æ ¸å¿ƒæœºåˆ¶ï¼

---

## è¯¦ç»†å¯¹æ¯”

### 1. SPDçš„ä¸‰å±‚è¿é€šæ€§ä¿è¯æœºåˆ¶

```
Builderå±‚ (å·²å®ç°âœ“)
  â†“ æˆ¿é—´æ‹“æ‰‘è¿æ¥éªŒè¯
Roomå±‚ (æœªå®ç°âœ—) â† å…³é”®ç¼ºå¤±ï¼
  â†“ PatchRoomå†…éƒ¨è¿é€šæ€§æ£€æŸ¥
  â†“ ä½¿ç”¨PathFinder.buildDistanceMapéªŒè¯
  â†“ å‘ç°å­¤ç«‹åŒºåŸŸ â†’ é™ä½fillç‡ â†’ é‡æ–°ç”Ÿæˆ
Levelå±‚ (å·²å®ç°âœ“)
  â†“ æœ€ç»ˆå…¨å±€è¿é€šæ€§éªŒè¯
```

### 2. å½“å‰å®ç° vs SPDå®ç°

#### å½“å‰å®ç°ï¼ˆæˆ‘ä»¬çš„ä»£ç ï¼‰

**ä½ç½®**: `RegularLevel.PostProcess()` â†’ `ValidateAndFixConnectivity()`

```csharp
// âœ“ ä¼˜ç‚¹ï¼šåœ¨Levelå±‚éªŒè¯å…¨å±€è¿é€šæ€§
ConnectivityValidation validation = PathFinder.ValidateConnectivity(
    this, entrancePos, exitPos, 0.7f
);

// âœ“ ä¼˜ç‚¹ï¼šè‡ªåŠ¨ä¿®å¤ä¸è¿é€šçš„åŒºåŸŸ
if (!validation.isValid) {
    ConnectTwoPoints(entrancePos, exitPos);
    ConnectIsolatedRegions(validation.isolatedRegions);
}
```

**é—®é¢˜**ï¼š
- âœ— åªåœ¨Levelå±‚éªŒè¯ï¼Œ**å¤ªæ™šäº†**
- âœ— æˆ¿é—´å†…éƒ¨å¯èƒ½å·²ç»ç”Ÿæˆäº†æ­»èƒ¡åŒ
- âœ— ä¿®å¤æ˜¯"æš´åŠ›"çš„ï¼ˆç›´æ¥è¿æ¥ï¼‰ï¼Œä¸å¤Ÿä¼˜é›…

#### SPDå®ç°ï¼ˆæ ‡å‡†åšæ³•ï¼‰

**ä½ç½®**: `PatchRoom.setupPatch()` - **æˆ¿é—´ç»˜åˆ¶æ—¶**éªŒè¯

```java
// SPDçš„æ ¸å¿ƒç®—æ³•
do {
    // 1. ç”Ÿæˆpatchå›¾æ¡ˆ
    patch = Patch.generate(width-2, height-2, fill, clustering, true);
    
    // 2. ç¡®ä¿é—¨é™„è¿‘å¯é€šè¡Œ
    for (Door door : connected.values()) {
        patch[doorNearby] = false;  // æ¸…ç©ºé—¨é™„è¿‘
    }
    
    // 3. BFSéªŒè¯è¿é€šæ€§
    PathFinder.buildDistanceMap(startPoint, BArray.not(patch, null));
    
    // 4. æ£€æŸ¥æ˜¯å¦æœ‰å­¤ç«‹åŒºåŸŸ
    valid = true;
    for (int i = 0; i < patch.length; i++) {
        if (!patch[i] && PathFinder.distance[i] == Integer.MAX_VALUE) {
            valid = false;  // å‘ç°å­¤ç«‹çš„å¯èµ°åŒºåŸŸ
            break;
        }
    }
    
    // 5. å¤±è´¥åé™ä½å¡«å……ç‡é‡è¯•
    if (!valid && attempts > 100) {
        fill -= 0.01f;
        attempts = 0;
    }
    
} while (!valid);  // ç›´åˆ°ç”Ÿæˆå®Œå…¨è¿é€šçš„æˆ¿é—´
```

**ä¼˜åŠ¿**ï¼š
- âœ“ **é¢„é˜²æ€§**ï¼šåœ¨æˆ¿é—´ç”Ÿæˆæ—¶å°±ä¿è¯è¿é€š
- âœ“ **ä¼˜é›…**ï¼šé€šè¿‡è°ƒæ•´fillç‡è€Œä¸æ˜¯æš´åŠ›ä¿®å¤
- âœ“ **å±€éƒ¨æ€§**ï¼šæ¯ä¸ªæˆ¿é—´ç‹¬ç«‹éªŒè¯ï¼Œé—®é¢˜æ—©å‘ç°
- âœ“ **æ€§èƒ½å¥½**ï¼šåªéªŒè¯æˆ¿é—´å†…éƒ¨ï¼ˆå°èŒƒå›´ï¼‰

---

## å…³é”®å·®å¼‚åˆ†æ

### å·®å¼‚1ï¼šéªŒè¯æ—¶æœº

| æ–¹é¢ | å½“å‰å®ç° | SPDå®ç° | å½±å“ |
|------|---------|---------|------|
| æ—¶æœº | Levelç”Ÿæˆå®Œæˆå | æ¯ä¸ªRoomç»˜åˆ¶æ—¶ | SPDæ›´æ—©å‘ç°é—®é¢˜ |
| èŒƒå›´ | æ•´ä¸ªåœ°å›¾ | å•ä¸ªæˆ¿é—´ | SPDéªŒè¯æ›´å¿« |
| ä¿®å¤ | æš´åŠ›è¿æ¥ | é‡æ–°ç”Ÿæˆ | SPDç»“æœæ›´è‡ªç„¶ |

### å·®å¼‚2ï¼šç®—æ³•å¤æ‚åº¦

```
å½“å‰å®ç°:
- éªŒè¯: O(W * H) - æ•´ä¸ªåœ°å›¾
- ä¿®å¤: O(å­¤ç«‹åŒºåŸŸæ•° * W * H) - å¯èƒ½å¾ˆæ…¢

SPDå®ç°:
- éªŒè¯: O(æˆ¿é—´æ•° * æˆ¿é—´å¤§å°) - åˆ†æ•£éªŒè¯
- ä¿®å¤: O(æˆ¿é—´å¤§å°) - åªé‡æ–°ç”Ÿæˆå•ä¸ªæˆ¿é—´
```

### å·®å¼‚3ï¼šç”Ÿæˆè´¨é‡

**å½“å‰å®ç°å¯èƒ½äº§ç”Ÿçš„é—®é¢˜**ï¼š
```
æˆ¿é—´Aå†…éƒ¨:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘ â”‚  â† è¿™ä¸ªå°è§’è½æ˜¯å­¤ç«‹çš„
â”‚ â–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘ â”‚     ä½†æˆ¿é—´å·²ç»ç»˜åˆ¶å®Œæˆ
â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚
â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Levelå±‚éªŒè¯æ—¶å‘ç°ï¼Œç„¶åæš´åŠ›è¿æ¥ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–“â–“ â”‚  â† å¼ºè¡Œæ‰“é€šï¼Œçœ‹èµ·æ¥ä¸è‡ªç„¶
â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ â”‚
â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**SPDå®ç°çš„ç»“æœ**ï¼š
```
ç¬¬ä¸€æ¬¡ç”Ÿæˆï¼ˆå¤±è´¥ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘ â”‚  â† æ£€æµ‹åˆ°å­¤ç«‹
â”‚ â–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘ â”‚     â†’ é™ä½fillç‡
â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç¬¬äºŒæ¬¡ç”Ÿæˆï¼ˆæˆåŠŸï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ â”‚  â† fillç‡é™ä½å
â”‚ â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ â”‚     è‡ªç„¶è¿é€š
â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## éœ€è¦æ”¹è¿›çš„åœ°æ–¹

### ğŸ”´ é«˜ä¼˜å…ˆçº§ï¼šå®ç°PatchRoomè¿é€šæ€§æ£€æŸ¥

#### 1. åˆ›å»ºPatchRoomåŸºç±»

```csharp
// Assets/_Project/Scripts/Levels/Rooms/PatchRoom.cs
public abstract class PatchRoom : StandardRoom
{
    protected bool[] patch;
    
    // å­ç±»éœ€è¦å®ç°
    protected abstract float FillPercent { get; }
    protected abstract int ClusteringPasses { get; }
    protected abstract bool EnsurePath { get; }
    
    public override bool Paint(Level level)
    {
        if (EnsurePath)
        {
            SetupPatchWithPathfinding(level);
        }
        else
        {
            patch = Patch.Generate(Width - 2, Height - 2, 
                                   FillPercent, ClusteringPasses, true);
        }
        
        return PaintTerrain(level);
    }
    
    private void SetupPatchWithPathfinding(Level level)
    {
        int attempts = 0;
        float fill = FillPercent;
        bool valid = false;
        
        do
        {
            // 1. ç”Ÿæˆpatch
            patch = Patch.Generate(Width - 2, Height - 2, 
                                   fill, ClusteringPasses, true);
            
            // 2. æ‰¾èµ·ç‚¹ï¼ˆä¼˜å…ˆé—¨é™„è¿‘ï¼‰
            int startIdx = GetPatchStartPoint();
            
            // 3. ç¡®ä¿é—¨é™„è¿‘å¯é€šè¡Œ
            ClearDoorAreas();
            
            // 4. æ„å»ºè·ç¦»åœ°å›¾ï¼ˆåªåœ¨æˆ¿é—´å†…éƒ¨ï¼‰
            bool[] walkable = GetWalkableArea();
            int[,] distanceMap = PathFinder.BuildDistanceMapLocal(
                startIdx, walkable, Width - 2, Height - 2
            );
            
            // 5. éªŒè¯æ‰€æœ‰å¯èµ°åŒºåŸŸéƒ½è¿é€š
            valid = true;
            for (int i = 0; i < patch.Length; i++)
            {
                if (!patch[i] && distanceMap[i % (Width-2), i / (Width-2)] == int.MaxValue)
                {
                    valid = false;
                    Debug.LogWarning($"æˆ¿é—´ {GetType().Name} åœ¨ä½ç½® {i} å‘ç°å­¤ç«‹åŒºåŸŸ");
                    break;
                }
            }
            
            attempts++;
            
            // 6. å¤±è´¥åé™ä½å¡«å……ç‡
            if (!valid && attempts > 100)
            {
                fill -= 0.01f;
                attempts = 0;
                Debug.LogWarning($"é™ä½å¡«å……ç‡åˆ° {fill:F2}");
            }
            
        } while (!valid);
        
        Debug.Log($"æˆ¿é—´ {GetType().Name} ç”ŸæˆæˆåŠŸï¼Œè€—æ—¶ {attempts} æ¬¡å°è¯•");
    }
    
    private int GetPatchStartPoint()
    {
        // å¦‚æœæœ‰é—¨ï¼Œä»é—¨é™„è¿‘å¼€å§‹
        foreach (var door in connected.Values)
        {
            if (door != null)
            {
                // è¿”å›é—¨å†…ä¾§çš„ä½ç½®
                int localX = door.x - left - 1;
                int localY = door.y - top - 1;
                return localX + localY * (Width - 2);
            }
        }
        
        // å¦åˆ™ä»ä¸­å¿ƒå¼€å§‹
        return (Width - 2) / 2 + (Height - 2) / 2 * (Width - 2);
    }
    
    private void ClearDoorAreas()
    {
        // ç¡®ä¿æ¯ä¸ªé—¨é™„è¿‘2æ ¼éƒ½æ˜¯å¯é€šè¡Œçš„
        foreach (var door in connected.Values)
        {
            if (door == null) continue;
            
            int localX = door.x - left - 1;
            int localY = door.y - top - 1;
            
            // é—¨å†…ä¾§2æ ¼
            if (door.x == left)
            {
                patch[XYToPatchIdx(localX + 1, localY)] = false;
                patch[XYToPatchIdx(localX + 2, localY)] = false;
            }
            else if (door.x == right)
            {
                patch[XYToPatchIdx(localX - 1, localY)] = false;
                patch[XYToPatchIdx(localX - 2, localY)] = false;
            }
            else if (door.y == top)
            {
                patch[XYToPatchIdx(localX, localY + 1)] = false;
                patch[XYToPatchIdx(localX, localY + 2)] = false;
            }
            else if (door.y == bottom)
            {
                patch[XYToPatchIdx(localX, localY - 1)] = false;
                patch[XYToPatchIdx(localX, localY - 2)] = false;
            }
        }
    }
    
    private bool[] GetWalkableArea()
    {
        bool[] walkable = new bool[patch.Length];
        for (int i = 0; i < patch.Length; i++)
        {
            walkable[i] = !patch[i];  // patch=trueè¡¨ç¤ºå¢™ï¼Œwalkable=false
        }
        return walkable;
    }
    
    private int XYToPatchIdx(int x, int y)
    {
        return x + y * (Width - 2);
    }
    
    protected virtual bool PaintTerrain(Level level)
    {
        for (int x = left + 1; x < right; x++)
        {
            for (int y = top + 1; y < bottom; y++)
            {
                int patchIdx = XYToPatchIdx(x - left - 1, y - top - 1);
                
                if (patch[patchIdx])
                {
                    level.SetTerrain(x, y, Terrain.Wall);
                }
                else
                {
                    level.SetTerrain(x, y, Terrain.Floor);
                }
            }
        }
        
        return true;
    }
}
```

#### 2. æ‰©å±•PathFinderæ”¯æŒå±€éƒ¨éªŒè¯

```csharp
// Assets/_Project/Scripts/Utils/PathFinder.cs
public static class PathFinder
{
    // ç°æœ‰çš„å…¨å±€æ–¹æ³•
    public static int[,] BuildDistanceMap(Level level, Vector2Int start, int maxDistance = -1)
    {
        // ... ç°æœ‰å®ç°
    }
    
    // æ–°å¢ï¼šå±€éƒ¨è·ç¦»åœ°å›¾ï¼ˆç”¨äºæˆ¿é—´å†…éƒ¨ï¼‰
    public static int[,] BuildDistanceMapLocal(int startIdx, bool[] walkable, int width, int height)
    {
        int[,] distanceMap = new int[width, height];
        
        // åˆå§‹åŒ–ä¸ºä¸å¯è¾¾
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                distanceMap[x, y] = int.MaxValue;
            }
        }
        
        // BFS
        Queue<int> queue = new Queue<int>();
        queue.Enqueue(startIdx);
        
        int startX = startIdx % width;
        int startY = startIdx / width;
        distanceMap[startX, startY] = 0;
        
        while (queue.Count > 0)
        {
            int currentIdx = queue.Dequeue();
            int x = currentIdx % width;
            int y = currentIdx / width;
            int currentDist = distanceMap[x, y];
            
            // æ£€æŸ¥å››ä¸ªæ–¹å‘
            int[] dx = { 0, 0, -1, 1 };
            int[] dy = { 1, -1, 0, 0 };
            
            for (int i = 0; i < 4; i++)
            {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                // è¾¹ç•Œæ£€æŸ¥
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    continue;
                
                int nextIdx = nx + ny * width;
                
                // å¯é€šè¡Œä¸”æœªè®¿é—®
                if (walkable[nextIdx] && distanceMap[nx, ny] == int.MaxValue)
                {
                    distanceMap[nx, ny] = currentDist + 1;
                    queue.Enqueue(nextIdx);
                }
            }
        }
        
        return distanceMap;
    }
}
```

#### 3. åˆ›å»ºPatchç”Ÿæˆå™¨

```csharp
// Assets/_Project/Scripts/Levels/Features/Patch.cs
public static class Patch
{
    /// <summary>
    /// ç”Ÿæˆpatchå›¾æ¡ˆï¼ˆç»†èƒè‡ªåŠ¨æœºï¼‰
    /// </summary>
    /// <param name="width">å®½åº¦</param>
    /// <param name="height">é«˜åº¦</param>
    /// <param name="fill">å¡«å……ç‡ (0-1)</param>
    /// <param name="passes">èšç±»è¿­ä»£æ¬¡æ•°</param>
    /// <param name="diagonals">æ˜¯å¦è€ƒè™‘å¯¹è§’çº¿</param>
    /// <returns>patchæ•°ç»„ï¼Œtrue=å¢™ï¼Œfalse=åœ°æ¿</returns>
    public static bool[] Generate(int width, int height, float fill, int passes, bool diagonals)
    {
        bool[] patch = new bool[width * height];
        
        // 1. éšæœºåˆå§‹åŒ–
        for (int i = 0; i < patch.Length; i++)
        {
            patch[i] = Random.value < fill;
        }
        
        // 2. ç»†èƒè‡ªåŠ¨æœºèšç±»
        for (int pass = 0; pass < passes; pass++)
        {
            bool[] next = new bool[patch.Length];
            
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int idx = x + y * width;
                    int neighbors = CountNeighbors(patch, x, y, width, height, diagonals);
                    
                    // è§„åˆ™ï¼šå¦‚æœå‘¨å›´å¢™å¤šï¼Œè‡ªå·±ä¹Ÿå˜æˆå¢™
                    if (diagonals)
                    {
                        next[idx] = neighbors >= 5;  // 8é‚»å±…ä¸­>=5ä¸ªå¢™
                    }
                    else
                    {
                        next[idx] = neighbors >= 2;  // 4é‚»å±…ä¸­>=2ä¸ªå¢™
                    }
                }
            }
            
            patch = next;
        }
        
        return patch;
    }
    
    private static int CountNeighbors(bool[] patch, int x, int y, int width, int height, bool diagonals)
    {
        int count = 0;
        
        int[] dx = diagonals ? new[] { -1, 0, 1, -1, 1, -1, 0, 1 } : new[] { 0, 0, -1, 1 };
        int[] dy = diagonals ? new[] { -1, -1, -1, 0, 0, 1, 1, 1 } : new[] { 1, -1, 0, 0 };
        
        for (int i = 0; i < dx.Length; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            if (nx >= 0 && nx < width && ny >= 0 && ny < height)
            {
                if (patch[nx + ny * width])
                    count++;
            }
            else
            {
                // è¾¹ç•Œå¤–è§†ä¸ºå¢™
                count++;
            }
        }
        
        return count;
    }
}
```

#### 4. åˆ›å»ºå…·ä½“çš„PatchRoomå­ç±»

```csharp
// Assets/_Project/Scripts/Levels/Rooms/Standard/GrassyGraveRoom.cs
public class GrassyGraveRoom : PatchRoom
{
    protected override float FillPercent => 0.45f;
    protected override int ClusteringPasses => 4;
    protected override bool EnsurePath => true;  // å¿…é¡»ä¿è¯è¿é€š
    
    protected override bool PaintTerrain(Level level)
    {
        // å…ˆè°ƒç”¨åŸºç±»ç»˜åˆ¶å¢™å’Œåœ°æ¿
        base.PaintTerrain(level);
        
        // ç„¶åæ·»åŠ è‰åœ°è£…é¥°
        for (int x = left + 1; x < right; x++)
        {
            for (int y = top + 1; y < bottom; y++)
            {
                int patchIdx = XYToPatchIdx(x - left - 1, y - top - 1);
                
                if (!patch[patchIdx] && Random.value < 0.3f)
                {
                    level.SetTerrain(x, y, Terrain.Grass);
                }
            }
        }
        
        return true;
    }
}
```

### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ï¼šä¼˜åŒ–ç°æœ‰Levelå±‚éªŒè¯

#### æ”¹è¿›ç‚¹1ï¼šå‡å°‘æš´åŠ›ä¿®å¤

```csharp
// å½“å‰çš„ConnectTwoPointså¤ªæš´åŠ›ï¼Œæ”¹è¿›ï¼š
private void ConnectTwoPoints(Vector2Int from, Vector2Int to)
{
    // ä½¿ç”¨A*å¯»è·¯è€Œä¸æ˜¯ç›´çº¿è¿æ¥
    List<Vector2Int> path = AStarPath(from, to);
    
    foreach (var pos in path)
    {
        // åªåœ¨å¿…è¦æ—¶æ‰“é€šå¢™å£
        if (GetTerrain(pos) == Terrain.Wall)
        {
            SetTerrain(pos, Terrain.Floor);
        }
    }
}
```

#### æ”¹è¿›ç‚¹2ï¼šéªŒè¯æ—¶æœºå‰ç§»

```csharp
// åœ¨PaintRooms()åç«‹å³éªŒè¯ï¼Œè€Œä¸æ˜¯ç­‰åˆ°PostProcess()
protected void PaintRooms()
{
    foreach (Room room in rooms)
    {
        room.Paint(this);
        
        // æ¯ç»˜åˆ¶ä¸€ä¸ªæˆ¿é—´å°±éªŒè¯ä¸€æ¬¡
        if (room is PatchRoom)
        {
            ValidateRoomConnectivity(room);
        }
    }
}
```

---

## å®æ–½è®¡åˆ’

### Phase 1: æ ¸å¿ƒPatchRoomå®ç° (4-6å°æ—¶)
- [ ] åˆ›å»º`Patch.cs`ç”Ÿæˆå™¨
- [ ] æ‰©å±•`PathFinder.cs`æ”¯æŒå±€éƒ¨éªŒè¯
- [ ] å®ç°`PatchRoom.cs`åŸºç±»
- [ ] æµ‹è¯•åŸºæœ¬è¿é€šæ€§æ£€æŸ¥

### Phase 2: å…·ä½“æˆ¿é—´ç±»å‹ (2-3å°æ—¶)
- [ ] `GrassyGraveRoom.cs`
- [ ] `RuinsRoom.cs`
- [ ] `PillarsRoom.cs`
- [ ] æµ‹è¯•å„ç§æˆ¿é—´ç±»å‹

### Phase 3: é›†æˆå’Œä¼˜åŒ– (2-3å°æ—¶)
- [ ] ä¿®æ”¹Builderä½¿ç”¨PatchRoom
- [ ] ä¼˜åŒ–Levelå±‚éªŒè¯ï¼ˆå‡å°‘æš´åŠ›ä¿®å¤ï¼‰
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] å®Œæ•´æµ‹è¯•å¥—ä»¶

### Phase 4: æ–‡æ¡£å’Œå·¥å…· (1-2å°æ—¶)
- [ ] æ›´æ–°è¯Šæ–­å·¥å…·æ”¯æŒæˆ¿é—´çº§éªŒè¯
- [ ] æ·»åŠ å¯è§†åŒ–æˆ¿é—´å†…éƒ¨è¿é€šæ€§
- [ ] ç¼–å†™ä½¿ç”¨æ–‡æ¡£

**æ€»è®¡**: 9-14å°æ—¶

---

## æµ‹è¯•æ–¹æ¡ˆ

### å•å…ƒæµ‹è¯•

```csharp
[Test]
public void TestPatchRoomConnectivity()
{
    // 1. åˆ›å»ºæµ‹è¯•æˆ¿é—´
    var room = new GrassyGraveRoom();
    room.SetSize(10, 10);
    
    // 2. ç”Ÿæˆpatch
    room.Paint(testLevel);
    
    // 3. éªŒè¯è¿é€šæ€§
    bool[] walkable = room.GetWalkableArea();
    var distanceMap = PathFinder.BuildDistanceMapLocal(0, walkable, 8, 8);
    
    // 4. æ£€æŸ¥æ‰€æœ‰å¯èµ°åŒºåŸŸéƒ½å¯è¾¾
    for (int i = 0; i < walkable.Length; i++)
    {
        if (walkable[i])
        {
            Assert.AreNotEqual(int.MaxValue, distanceMap[i % 8, i / 8], 
                $"Position {i} is isolated!");
        }
    }
}
```

### å‹åŠ›æµ‹è¯•

```csharp
[Test]
public void TestPatchRoomStressTest()
{
    // ç”Ÿæˆ1000ä¸ªæˆ¿é—´ï¼Œç¡®ä¿éƒ½èƒ½æˆåŠŸç”Ÿæˆä¸”è¿é€š
    for (int i = 0; i < 1000; i++)
    {
        var room = new GrassyGraveRoom();
        room.SetSize(Random.Range(5, 15), Random.Range(5, 15));
        
        bool success = room.Paint(testLevel);
        Assert.IsTrue(success, $"Room {i} failed to generate");
        
        // éªŒè¯è¿é€šæ€§
        ValidateRoomConnectivity(room);
    }
}
```

---

## æ€»ç»“

### å½“å‰çŠ¶æ€è¯„ä¼°

| åŠŸèƒ½ | å®Œæˆåº¦ | è´¨é‡ | è¯´æ˜ |
|------|--------|------|------|
| Levelå±‚è¿é€šæ€§éªŒè¯ | âœ“ 100% | â­â­â­ | åŸºæœ¬åŠŸèƒ½å®Œæ•´ |
| å­¤ç«‹åŒºåŸŸæ£€æµ‹ | âœ“ 100% | â­â­â­â­ | ç®—æ³•æ­£ç¡® |
| è‡ªåŠ¨ä¿®å¤ | âœ“ 100% | â­â­ | å¤ªæš´åŠ›ï¼Œéœ€ä¼˜åŒ– |
| **Roomå±‚éªŒè¯** | âœ— 0% | - | **å…³é”®ç¼ºå¤±** |
| ç¼–è¾‘å™¨å·¥å…· | âœ“ 100% | â­â­â­â­ | åŠŸèƒ½å®Œå–„ |

### ä¸SPDå¯¹æ¯”

```
SPDæ ‡å‡†: â­â­â­â­â­ (ä¸‰å±‚éªŒè¯ï¼Œé¢„é˜²æ€§è®¾è®¡)
å½“å‰å®ç°: â­â­â­ (ä¸¤å±‚éªŒè¯ï¼Œä¿®å¤æ€§è®¾è®¡)

å·®è·: ç¼ºå°‘Roomå±‚çš„é¢„é˜²æ€§éªŒè¯
```

### å»ºè®®

1. **ç«‹å³å®æ–½**: PatchRoomè¿é€šæ€§æ£€æŸ¥ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
2. **é€æ­¥ä¼˜åŒ–**: Levelå±‚ä¿®å¤ç®—æ³•ï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰
3. **é•¿æœŸæ”¹è¿›**: å®Œæ•´çš„Builder+Room+Levelä¸‰å±‚éªŒè¯ä½“ç³»

å®æ–½PatchRoomåï¼Œè¿é€šæ€§ä¿è¯å°†è¾¾åˆ°SPDçš„æ ‡å‡†ï¼ˆâ­â­â­â­â­ï¼‰ã€‚

---

**æŠ¥å‘Šç»“æŸ**

